<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子土星</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #050505 0%, #0b0b10 100%); }
        #ui-layer { position: absolute; top: 30px; left: 30px; z-index: 10; pointer-events: none; }
        .glass-panel { background: rgba(5, 5, 5, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 2px; border-left: 2px solid #c5a059; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9); max-width: 280px; }
        h1 { font-weight: 200; font-size: 1.8rem; margin: 0 0 10px 0; color: #e0cda7; letter-spacing: 4px; text-transform: uppercase; }
        .status-text { font-size: 0.85rem; color: #888; line-height: 1.6; font-family: monospace; }
        .highlight { color: #c5a059; font-weight: bold; }
        #controls { position: absolute; bottom: 40px; right: 40px; z-index: 10; pointer-events: auto; }
        #author-btn { position: absolute; top: 40px; right: 40px; z-index: 20; pointer-events: auto; text-decoration: none; color: #c5a059; border: 1px solid rgba(197, 160, 89, 0.4); background: rgba(0, 0, 0, 0.6); padding: 8px 20px; font-size: 0.8rem; border-radius: 20px; backdrop-filter: blur(4px); }
        button { background: transparent; border: 1px solid rgba(197, 160, 89, 0.3); color: #c5a059; padding: 12px 30px; font-size: 0.8rem; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; text-align: center; color: #444; font-size: 0.8rem; letter-spacing: 3px; text-transform: uppercase; }
        
        #fps-counter {
            position: absolute; top: 10px; right: 150px; color: #555;
            font-family: monospace; font-size: 11px; z-index: 5; text-align: right; line-height: 1.4;
        }
        .res-high { color: #4caf50; }
        .res-med { color: #ff9800; }
        .res-low { color: #f44336; }
        .input_video { display: none; }
    </style>
</head>
<body>

    <video class="input_video"></video>
    <a id="author-btn" href="https://www.yjln.com" target="_blank">By Mr.lun</a>
    <div id="fps-counter">初始化引擎...</div>
    <div id="loading">正在构建百万粒子与行星数据...</div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>土星</h1>
            <div class="status-text">
                数据流状态: <span id="status-indicator" class="highlight">待机</span><br><br>
                > 粒子密度: <span id="particle-count-display" class="highlight">100%</span><br>
                > 渲染策略: <span id="res-mode">动态几何优化</span><br>
                > 物理反馈: 实时
            </div>
        </div>
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()">全屏沉浸体验</button>
    </div>

    <div id="canvas-container"></div>

    <!-- 1. 顶点着色器 -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute float opacityAttr;
        attribute float orbitSpeed;
        attribute float isRing;
        
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        uniform float uTime;
        uniform float uScale;
        uniform float uRotationX;
        uniform float uPixelRatio; // 即使是低分辨率，也通过这个参数修正大小
        
        mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle)); }
        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
            vec3 pos = position;

            // 旋转逻辑
            if (isRing > 0.5) {
                float angleOffset = uTime * orbitSpeed * 0.2;
                vec2 rotatedXZ = rotate2d(angleOffset) * pos.xz;
                pos.x = rotatedXZ.x; pos.z = rotatedXZ.y;
            } else {
                float bodyAngle = uTime * 0.03;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x; pos.z = rotatedXZ.y;
            }

            float cx = cos(uRotationX);
            float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx;
            float rz = pos.y * sx + pos.z * cx;
            pos.y = ry; pos.z = rz;

            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z;
            vDist = dist;

            // 湍流噪点
            float chaosThreshold = 25.0; 
            if (dist < chaosThreshold && dist > 0.1) {
                float chaosIntensity = 1.0 - (dist / chaosThreshold);
                chaosIntensity = pow(chaosIntensity, 3.0);
                float highFreqTime = uTime * 40.0; 
                vec3 noiseVec = vec3(
                    sin(highFreqTime + pos.x * 10.0) * hash(pos.y),
                    cos(highFreqTime + pos.y * 10.0) * hash(pos.x),
                    sin(highFreqTime * 0.5) * hash(pos.z)
                ) * chaosIntensity * 3.0;
                mvPosition.xyz += noiseVec;
            }
            
            gl_Position = projectionMatrix * mvPosition;
            
            float pointSize = size * (350.0 / dist); 
            pointSize *= 0.55; 
            if (isRing < 0.5 && dist < 50.0) pointSize *= 0.8; 
            
            // 修正低分辨率下的变白问题
            pointSize *= pow(uPixelRatio, 0.8);

            gl_PointSize = clamp(pointSize, 0.0, 300.0);

            vColor = customColor;
            vOpacity = opacityAttr;
            vScaleFactor = uScale;
            vIsRing = isRing;
        }
    </script>

    <!-- 2. 片元着色器 -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float glow = smoothstep(1.0, 0.4, r); 
            float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);
            vec3 deepGold = vec3(0.35, 0.22, 0.05); 
            float colorMix = smoothstep(0.1, 0.9, t);
            vec3 baseColor = mix(deepGold, vColor, colorMix);
            float brightness = 0.2 + 1.0 * t; 
            float densityAlpha = 0.25 + 0.45 * smoothstep(0.0, 0.5, t);
            vec3 finalColor = baseColor * brightness;
            if (vDist < 40.0) {
                float closeMix = 1.0 - (vDist / 40.0);
                if (vIsRing < 0.5) {
                    vec3 deepTexture = pow(vColor, vec3(1.4)) * 1.5; 
                    finalColor = mix(finalColor, deepTexture, closeMix * 0.8);
                } else {
                    finalColor += vec3(0.15, 0.12, 0.1) * closeMix;
                }
            }
            float depthAlpha = 1.0;
            if (vDist < 10.0) depthAlpha = smoothstep(0.0, 10.0, vDist);
            float alpha = glow * vOpacity * densityAlpha * depthAlpha;
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <!-- 3. 星空顶点着色器 -->
    <script type="x-shader/x-vertex" id="starVertexShader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float uTime;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float dist = -mvPosition.z;
            gl_PointSize = size * (1000.0 / dist); 
            gl_PointSize = clamp(gl_PointSize, 1.0, 8.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- 4. 星空片元着色器 -->
    <script type="x-shader/x-fragment" id="starFragmentShader">
        varying vec3 vColor;
        uniform float uTime;
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float noise = random(gl_FragCoord.xy);
            float twinkle = 0.7 + 0.3 * sin(uTime * 2.0 + noise * 10.0);
            float glow = 1.0 - r;
            glow = pow(glow, 1.5);
            gl_FragColor = vec4(vColor * twinkle, glow * 0.8);
        }
    </script>

    <!-- 5. 行星着色器 -->
    <script type="x-shader/x-vertex" id="planetVertexShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="planetFragmentShader">
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float noiseScale;
        uniform vec3 lightDir;
        uniform float atmosphere;
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            for (int i = 0; i < 5; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }
        void main() {
            float n = fbm(vUv * noiseScale);
            vec3 albedo = mix(color1, color2, n);
            vec3 normal = normalize(vNormal);
            vec3 light = normalize(lightDir);
            float diff = max(dot(normal, light), 0.05);
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
            vec3 finalColor = albedo * diff + atmosphere * vec3(0.5, 0.6, 1.0) * fresnel;
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        let scene, camera, renderer, particles, stars, nebula;
        let planetGroup;
        let uniforms, starUniforms;
        
        let targetScale = 1.0;
        let targetRotX = 0.4;
        let currentScale = 1.0;
        let currentRotX = 0.4;
        let isHandDetected = false;
        
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status-indicator');
        const loadingElement = document.getElementById('loading');
        const fpsCounter = document.getElementById('fps-counter');
        const resModeText = document.getElementById('res-mode');
        const particleCountText = document.getElementById('particle-count-display');

        // --- 性能控制变量 (调整版) ---
        const MAX_PIXEL_RATIO = Math.min(window.devicePixelRatio, 2.0);
        const MIN_PIXEL_RATIO = 0.7; // 分辨率下限设高一点，因为主要靠砍粒子
        let currentPixelRatio = MAX_PIXEL_RATIO;
        
        const TOTAL_PARTICLES = 1200000;
        const MIN_PARTICLES = 250000; // 粒子下限，再低就太秃了
        let currentParticleDrawCount = TOTAL_PARTICLES; 
        
        let lastFrameTime = 0;
        let frameCount = 0;
        let lastFpsCheckTime = 0;
        const FPS_CHECK_INTERVAL = 800; 
        let optimizeCoolDown = 0; 

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.00015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);

            initSaturn();
            initStarfield();
            initPlanets();

            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                alpha: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(currentPixelRatio);
            renderer.setClearColor(0x000000, 0); 
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(currentPixelRatio);
            });

            requestAnimationFrame(animate);
        }

        // --- 核心调度算法：优先砍粒子 ---
        function optimizePerformance(fps) {
            if (optimizeCoolDown > 0) {
                optimizeCoolDown--;
                return;
            }

            let stateChanged = false;

            // 1. 降级逻辑 (FPS < 50)
            if (fps < 50) {
                // 优先策略：只要粒子还没到底，就砍粒子！
                // 这能最直接减轻 Vertex Shader 压力
                if (currentParticleDrawCount > MIN_PARTICLES) {
                    currentParticleDrawCount = Math.floor(currentParticleDrawCount * 0.85); // 每次砍15%
                    particles.geometry.setDrawRange(0, currentParticleDrawCount);
                    stateChanged = true;
                    optimizeCoolDown = 1;
                } 
                // 后备策略：粒子已经砍到底了还是很卡，那只能降分辨率了
                else if (currentPixelRatio > MIN_PIXEL_RATIO) {
                    currentPixelRatio = Math.max(MIN_PIXEL_RATIO, currentPixelRatio * 0.9);
                    renderer.setPixelRatio(currentPixelRatio);
                    uniforms.uPixelRatio.value = currentPixelRatio;
                    stateChanged = true;
                    optimizeCoolDown = 2;
                }
            } 
            // 2. 升级逻辑 (FPS > 58)
            else if (fps >= 58) {
                // 回血时，优先把分辨率稍微提一点（保证清晰度）
                if (currentPixelRatio < MAX_PIXEL_RATIO && currentPixelRatio < 1.0) {
                    currentPixelRatio += 0.05;
                    renderer.setPixelRatio(currentPixelRatio);
                    uniforms.uPixelRatio.value = currentPixelRatio;
                    stateChanged = true;
                    optimizeCoolDown = 2;
                }
                // 然后再把粒子慢慢加回来
                else if (currentParticleDrawCount < TOTAL_PARTICLES) {
                    currentParticleDrawCount = Math.min(TOTAL_PARTICLES, Math.floor(currentParticleDrawCount * 1.1));
                    particles.geometry.setDrawRange(0, currentParticleDrawCount);
                    stateChanged = true;
                    optimizeCoolDown = 1;
                }
                // 如果粒子也满了，继续提升分辨率到极致
                else if (currentPixelRatio < MAX_PIXEL_RATIO) {
                    currentPixelRatio = Math.min(MAX_PIXEL_RATIO, currentPixelRatio + 0.05);
                    renderer.setPixelRatio(currentPixelRatio);
                    uniforms.uPixelRatio.value = currentPixelRatio;
                    stateChanged = true;
                    optimizeCoolDown = 3;
                }
            }

            if (stateChanged) updateUI(fps);
        }

        function updateUI(fps) {
            const resPercent = Math.round((currentPixelRatio / MAX_PIXEL_RATIO) * 100);
            const particlePercent = Math.round((currentParticleDrawCount / TOTAL_PARTICLES) * 100);
            
            let fpsColor = fps >= 50 ? '#4caf50' : '#f44336';
            
            fpsCounter.innerHTML = `
                FPS: <span style="color:${fpsColor}">${fps}</span><br>
                Res: ${resPercent}%<br>
                Dots: ${particlePercent}%
            `;

            particleCountText.innerText = particlePercent + "%";
            
            if (particlePercent < 70) {
                resModeText.innerHTML = "几何精简模式";
                resModeText.style.color = "#f44336"; // 红
                particleCountText.style.color = "#f44336";
            } else if (particlePercent < 95) {
                resModeText.innerHTML = "平衡优化模式";
                resModeText.style.color = "#ff9800"; // 橙
                particleCountText.style.color = "#ff9800";
            } else {
                resModeText.innerHTML = "原生极致画质";
                resModeText.style.color = "#4caf50"; // 绿
                particleCountText.style.color = "#4caf50";
            }
        }

        function initSaturn() {
            const particleCount = TOTAL_PARTICLES; 
            const geometry = new THREE.BufferGeometry();
            
            // 为了能够均匀地减少粒子（而不是从外圈直接切掉），我们需要打乱生成的顺序
            // 先用一个临时数组存储所有数据
            const tempData = [];

            const bodyColors = [
                new THREE.Color('#E3DAC5'), new THREE.Color('#C9A070'), 
                new THREE.Color('#E3DAC5'), new THREE.Color('#B08D55')  
            ];
            const colorRingC = new THREE.Color('#2A2520'); 
            const colorRingB_Inner = new THREE.Color('#CDBFA0'); 
            const colorRingB_Outer = new THREE.Color('#DCCBBA'); 
            const colorCassini = new THREE.Color('#050505'); 
            const colorRingA = new THREE.Color('#989085'); 
            const colorRingF = new THREE.Color('#AFAFA0'); 
            const R_PLANET = 18; 

            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, size, opacity, speed, isRingVal;
                // 1. 生成本体 (25%)
                if (i < particleCount * 0.25) {
                    isRingVal = 0.0; speed = 0.0;
                    const u = Math.random(); const v = Math.random();
                    const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                    const rad = R_PLANET;
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    let rawY = rad * Math.cos(phi);
                    z = rad * Math.sin(phi) * Math.sin(theta);
                    y = rawY * 0.9;
                    let lat = (rawY / rad + 1.0) * 0.5; 
                    let bandNoise = Math.cos(lat * 40.0) * 0.8 + Math.cos(lat * 15.0) * 0.4;
                    let colIndex = Math.floor(lat * 4 + bandNoise) % 4;
                    if (colIndex < 0) colIndex = 0;
                    let baseCol = bodyColors[colIndex];
                    r = baseCol.r; g = baseCol.g; b = baseCol.b;
                    size = 1.0 + Math.random() * 0.8; opacity = 0.8; 
                } 
                // 2. 生成光环 (75%)
                else {
                    isRingVal = 1.0;
                    let zoneRand = Math.random();
                    let ringRadius, ringCol;
                    if (zoneRand < 0.15) { 
                        ringRadius = R_PLANET * (1.235 + Math.random() * (1.525 - 1.235));
                        ringCol = colorRingC; size = 0.5; opacity = 0.3; 
                    } else if (zoneRand < 0.65) { 
                        let t = Math.random();
                        ringRadius = R_PLANET * (1.525 + t * (1.95 - 1.525));
                        ringCol = colorRingB_Inner.clone().lerp(colorRingB_Outer, t);
                        size = 0.8 + Math.random() * 0.6; opacity = 0.85; 
                        if (Math.sin(ringRadius * 2.0) > 0.8) opacity *= 1.2;
                    } else if (zoneRand < 0.69) { 
                        ringRadius = R_PLANET * (1.95 + Math.random() * (2.025 - 1.95));
                        ringCol = colorCassini; size = 0.3; opacity = 0.1; 
                    } else if (zoneRand < 0.99) { 
                        ringRadius = R_PLANET * (2.025 + Math.random() * (2.27 - 2.025));
                        ringCol = colorRingA; size = 0.7; opacity = 0.6;
                        if (ringRadius > R_PLANET * 2.2 && ringRadius < R_PLANET * 2.21) opacity = 0.1;
                    } else { 
                        ringRadius = R_PLANET * (2.32 + Math.random() * 0.02);
                        ringCol = colorRingF; size = 1.0; opacity = 0.7;
                    }
                    const theta = Math.random() * Math.PI * 2;
                    x = ringRadius * Math.cos(theta);
                    z = ringRadius * Math.sin(theta);
                    let thickness = 0.15;
                    if (ringRadius > R_PLANET * 2.3) thickness = 0.4; 
                    y = (Math.random() - 0.5) * thickness;
                    r = ringCol.r; g = ringCol.g; b = ringCol.b;
                    speed = 8.0 / Math.sqrt(ringRadius);
                }
                
                // 将单个粒子数据存入临时数组
                tempData.push({x, y, z, r, g, b, size, opacity, speed, isRingVal});
            }

            // --- 关键步骤：洗牌算法 (Fisher-Yates Shuffle) ---
            // 这确保了我们在减少 setDrawRange 时，是均匀地减少整个土星的粒子密度
            // 而不是直接把光环切没了
            for (let i = tempData.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tempData[i], tempData[j]] = [tempData[j], tempData[i]];
            }

            // 将洗牌后的数据填入 TypedArray
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const opacities = new Float32Array(particleCount);
            const orbitSpeeds = new Float32Array(particleCount);
            const isRings = new Float32Array(particleCount);

            for(let i = 0; i < particleCount; i++) {
                const p = tempData[i];
                positions[i*3] = p.x; positions[i*3+1] = p.y; positions[i*3+2] = p.z;
                colors[i*3] = p.r; colors[i*3+1] = p.g; colors[i*3+2] = p.b;
                sizes[i] = p.size;
                opacities[i] = p.opacity;
                orbitSpeeds[i] = p.speed;
                isRings[i] = p.isRingVal;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('orbitSpeed', new THREE.BufferAttribute(orbitSpeeds, 1));
            geometry.setAttribute('isRing', new THREE.BufferAttribute(isRings, 1));

            uniforms = {
                uTime: { value: 0 },
                uScale: { value: 1.0 },
                uRotationX: { value: 0.4 },
                uPixelRatio: { value: currentPixelRatio }
            };

            const material = new THREE.ShaderMaterial({
                depthWrite: false, blending: THREE.AdditiveBlending, 
                vertexColors: true, uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            particles.rotation.z = 26.73 * (Math.PI / 180); 
            scene.add(particles);
        }

        function initStarfield() {
            const starCount = 50000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(starCount * 3);
            const cols = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const starColors = [
                new THREE.Color('#9bb0ff'), new THREE.Color('#ffffff'), 
                new THREE.Color('#ffcc6f'), new THREE.Color('#ff7b7b')
            ];
            for(let i=0; i<starCount; i++) {
                const r = 400 + Math.random() * 3000; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.cos(phi);
                pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                const colorType = Math.random();
                let c;
                if(colorType > 0.9) c = starColors[0]; else if(colorType > 0.6) c = starColors[1];
                else if(colorType > 0.3) c = starColors[2]; else c = starColors[3];
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                sizes[i] = 1.0 + Math.random() * 3.0;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starUniforms = { uTime: { value: 0 } };
            const mat = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: document.getElementById('starFragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            stars = new THREE.Points(geo, mat);
            scene.add(stars);

            const nebulaCount = 100;
            const nebGeo = new THREE.BufferGeometry();
            const nebPos = new Float32Array(nebulaCount * 3);
            const nebCols = new Float32Array(nebulaCount * 3);
            const nebSizes = new Float32Array(nebulaCount);
            for(let i=0; i<nebulaCount; i++) {
                const r = 800 + Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.PI / 2 + (Math.random() - 0.5) * 1.5; 
                nebPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                nebPos[i*3+1] = r * Math.cos(phi);
                nebPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                const nc = new THREE.Color().setHSL(0.6 + Math.random()*0.2, 0.8, 0.05);
                nebCols[i*3] = nc.r; nebCols[i*3+1] = nc.g; nebCols[i*3+2] = nc.b;
                nebSizes[i] = 400.0 + Math.random() * 600.0;
            }
            nebGeo.setAttribute('position', new THREE.BufferAttribute(nebPos, 3));
            nebGeo.setAttribute('customColor', new THREE.BufferAttribute(nebCols, 3));
            nebGeo.setAttribute('size', new THREE.BufferAttribute(nebSizes, 1));
            const nebShaderMat = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        float r = dot(cxy, cxy);
                        if(r > 1.0) discard;
                        float glow = pow(1.0 - r, 2.0);
                        gl_FragColor = vec4(vColor, glow * 0.1); 
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            nebula = new THREE.Points(nebGeo, nebShaderMat);
            scene.add(nebula);
        }

        function initPlanets() {
            planetGroup = new THREE.Group();
            scene.add(planetGroup);
            const vShader = document.getElementById('planetVertexShader').textContent;
            const fShader = document.getElementById('planetFragmentShader').textContent;
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#b33a00'), new THREE.Color('#d16830'), 8.0, 
                { x: -300, y: 120, z: -450 }, 10, 0.3 
            );
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#001e4d'), new THREE.Color('#ffffff'), 5.0, 
                { x: 380, y: -100, z: -600 }, 14, 0.6 
            );
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#666666'), new THREE.Color('#aaaaaa'), 15.0, 
                { x: -180, y: -220, z: -350 }, 6, 0.1 
            );
        }

        function createPlanet(group, vShader, fShader, c1, c2, nScale, pos, radius, atmo) {
            const geo = new THREE.SphereGeometry(radius, 48, 48);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    color1: { value: c1 },
                    color2: { value: c2 },
                    noiseScale: { value: nScale },
                    lightDir: { value: new THREE.Vector3(1, 0.5, 1) },
                    atmosphere: { value: atmo }
                },
                vertexShader: vShader,
                fragmentShader: fShader
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            group.add(mesh);
        }

        const clock = new THREE.Clock();
        let autoIdleTime = 0;

        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (!lastFrameTime) lastFrameTime = timestamp;
            frameCount++;
            
            if (timestamp - lastFpsCheckTime >= FPS_CHECK_INTERVAL) {
                const fps = Math.round((frameCount * 1000) / (timestamp - lastFpsCheckTime));
                optimizePerformance(fps);
                if (timestamp % 1600 < 50) updateUI(fps); 
                frameCount = 0;
                lastFpsCheckTime = timestamp;
            }
            lastFrameTime = timestamp;

            const elapsedTime = clock.getElapsedTime();
            uniforms.uTime.value = elapsedTime;
            if(starUniforms) starUniforms.uTime.value = elapsedTime;

            if(stars) stars.rotation.y = elapsedTime * 0.005;
            if(nebula) nebula.rotation.y = elapsedTime * 0.003;
            
            if(planetGroup) {
                planetGroup.children.forEach((planet, idx) => {
                    planet.rotation.y = elapsedTime * (0.05 + idx * 0.02);
                });
                planetGroup.rotation.y = Math.sin(elapsedTime * 0.05) * 0.02;
            }

            if (!isHandDetected) {
                autoIdleTime += 0.005;
                targetScale = 1.0 + Math.sin(autoIdleTime) * 0.2;
                targetRotX = 0.4 + Math.sin(autoIdleTime * 0.3) * 0.15;
                statusElement.innerHTML = "系统状态: 自动巡航<br>输入信号: 等待中...";
                statusElement.style.color = "#666";
            } else {
                statusElement.innerHTML = "系统状态: 手动接管<br>输入信号: <span class='highlight'>已锁定</span>";
                statusElement.style.color = "#c5a059";
            }

            const lerpFactor = 0.08;
            currentScale += (targetScale - currentScale) * lerpFactor;
            currentRotX += (targetRotX - currentRotX) * lerpFactor;

            uniforms.uScale.value = currentScale;
            uniforms.uRotationX.value = currentRotX;

            renderer.render(scene, camera);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(results => {
            loadingElement.style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const hand = results.multiHandLandmarks[0];
                const p1 = hand[4]; const p2 = hand[8];
                const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
                const normDist = Math.max(0, Math.min(1, (dist - 0.02) / 0.25));
                targetScale = 0.15 + normDist * 2.35; 
                const y = hand[9].y;
                const normY = Math.max(0, Math.min(1, (y - 0.1) / 0.8));
                targetRotX = -0.6 + normY * 1.6;
            } else {
                isHandDetected = false;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().catch(e => { console.error(e); loadingElement.innerText = "摄像头启动失败"; });

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        initThree();
    </script>
</body>
</html>

以下是目前正在开发的新代码：
vision_controller.py：
import cv2
import mediapipe as mp
import math
import socket
import struct
import time

# --- 配置 ---
UDP_IP = "127.0.0.1"
UDP_PORT = 8888
CAMERA_ID = 0  # 如果你有多个摄像头，尝试改这个数字

# --- 初始化 UDP ---
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# --- 初始化 MediaPipe ---
mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils
# model_complexity=1 是平衡模式，0最快，2最准
hands = mp_hands.Hands(
    max_num_hands=1,
    model_complexity=1,
    min_detection_confidence=0.7,
    min_tracking_confidence=0.7
)

# --- 打开摄像头 ---
cap = cv2.VideoCapture(CAMERA_ID)

print(f"--- 视觉中枢已启动 ---")
print(f"目标地址: {UDP_IP}:{UDP_PORT}")
print("按 'q' 键退出")

# 平滑处理变量
smooth_scale = 1.0
smooth_rot_x = 0.0
smooth_rot_y = 0.0
LERP_FACTOR = 0.1  # 0.1 表示平滑度，越小越顺滑但延迟越高

while cap.isOpened():
    success, image = cap.read()
    if not success:
        print("忽略空帧")
        continue

    # 镜像翻转，让操作更符合直觉
    image = cv2.flip(image, 1)
    
    # 转换颜色空间 BGR -> RGB
    image.flags.writeable = False
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    
    # 推理
    results = hands.process(image_rgb)
    
    # 恢复可写状态用于绘图
    image.flags.writeable = True
    
    # 默认值（如果没有手，土星保持自旋状态）
    target_scale = 1.0
    target_rot_x = 0.5
    target_rot_y = 0.5
    has_hand = 0.0 # 0.0 无手, 1.0 有手

    if results.multi_hand_landmarks:
        has_hand = 1.0
        for hand_landmarks in results.multi_hand_landmarks:
            # 画骨骼
            mp_drawing.draw_landmarks(
                image, hand_landmarks, mp_hands.HAND_CONNECTIONS)
            
            # --- 核心逻辑：提取控制参数 ---
            
            # 1. 旋转控制：使用手腕 (节点0) 的位置
            # x, y 都是 0.0 ~ 1.0 的归一化坐标
            wrist = hand_landmarks.landmark[0]
            target_rot_x = wrist.x 
            target_rot_y = wrist.y

            # 2. 缩放控制：大拇指指尖(4) 与 食指指尖(8) 的距离
            thumb_tip = hand_landmarks.landmark[4]
            index_tip = hand_landmarks.landmark[8]
            
            # 计算欧几里得距离
            dist = math.sqrt((thumb_tip.x - index_tip.x)**2 + 
                             (thumb_tip.y - index_tip.y)**2)
            
            # 映射距离到缩放倍数 (经验值：距离0.05~0.3 映射为 0.5~2.5倍)
            # 你可以根据手感调整这些魔法数字
            norm_dist = max(0.0, min(1.0, (dist - 0.02) / 0.25))
            target_scale = 0.5 + norm_dist * 2.0

            # 在画面上显示数值
            cv2.putText(image, f"Scale: {target_scale:.2f}", (10, 30), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            cv2.putText(image, f"Pos: {target_rot_x:.2f}, {target_rot_y:.2f}", (10, 60), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

    # --- 简单平滑插值 (Lerp) 防止画面抖动 ---
    smooth_scale += (target_scale - smooth_scale) * LERP_FACTOR
    smooth_rot_x += (target_rot_x - smooth_rot_x) * LERP_FACTOR
    smooth_rot_y += (target_rot_y - smooth_rot_y) * LERP_FACTOR

    # --- 打包发送 UDP 数据 ---
    # 格式: '4f' 代表 4个 float (4字节浮点数)
    # 数据包内容: [是否有手, 缩放, 旋转X, 旋转Y]
    # C++ 端将直接把这些数据映射到内存
    packet = struct.pack('4f', has_hand, smooth_scale, smooth_rot_x, smooth_rot_y)
    sock.sendto(packet, (UDP_IP, UDP_PORT))

    cv2.imshow('Saturn Controller (Python)', image)
    
    if cv2.waitKey(5) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()

main.cpp：
/*
 * Particle Saturn - Native Engine
 * 核心技术: OpenGL 4.3 Compute Shaders + SSBO + UDP
 * 适配硬件: Intel Xe Graphics (12th Gen) 及以上
 */

 // --- 1. 引入必要的头文件 ---
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <iostream>
#include <vector>
#include <string>
#include <random>
#include <winsock2.h> // Windows 网络库

// --- 2. 告诉编译器链接网络库 (免去手动配置库依赖) ---
#pragma comment(lib, "ws2_32.lib")

// --- 3. 常量定义 ---
const unsigned int SCR_WIDTH = 1920;
const unsigned int SCR_HEIGHT = 1080;
const unsigned int PARTICLE_COUNT = 1000000; // 100万粒子 (核显建议上限)
const unsigned int WORK_GROUP_SIZE = 128;    // GPU 线程组大小

// --- 4. 粒子数据结构 (内存对齐非常重要) ---
struct Particle {
    glm::vec4 position; // x, y, z, size (w通道复用为大小)
    glm::vec4 velocity; // vx, vy, vz, orbitSpeed (w通道复用为轨道速度)
    glm::vec4 color;    // r, g, b, alpha
};

// --- 5. 着色器源码 (直接嵌入，方便管理) ---

// [计算着色器]: 物理引擎的核心，每一帧更新粒子位置
const char* computeShaderSource = R"(
#version 430 core
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// 对应 CPU 的 Particle 结构
struct Particle {
    vec4 position;
    vec4 velocity;
    vec4 color;
};

// 绑定 SSBO (Shader Storage Buffer Object)
layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

uniform float uTime;
uniform float uDt;
uniform float uHandScale; // 手势缩放
uniform float uHandHas;   // 是否有手

// 伪随机函数
float hash(float n) { return fract(sin(n) * 43758.5453123); }

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= 1000000) return; // 防止越界

    Particle p = particles[id];

    // 1. 基础轨道运动
    // 从 velocity.w 取出预设的轨道速度
    float speed = p.velocity.w; 
    
    // 如果有手势，改变速度 (模拟时间膨胀/压缩)
    float timeFactor = 1.0;
    if (uHandHas > 0.5) {
        // 手势捏合时，粒子运动变慢或变快
        timeFactor = uHandScale; 
    }

    // 简单的旋转逻辑 (围绕 Y 轴)
    float angle = speed * uDt * 0.1 * timeFactor;
    float c = cos(angle);
    float s = sin(angle);
    
    // 旋转矩阵应用
    float nx = p.position.x * c - p.position.z * s;
    float nz = p.position.x * s + p.position.z * c;
    
    p.position.x = nx;
    p.position.z = nz;

    // 2. 交互扰动 (Turbulence)
    // 如果手捏得特别紧 (Scale < 0.8)，增加一点垂直抖动
    if (uHandHas > 0.5 && uHandScale < 0.8) {
        float noise = hash(float(id) * uTime);
        p.position.y += (noise - 0.5) * 0.05; 
        // 简单的弹簧回复力，把粒子拉回赤道平面
        p.position.y *= 0.99; 
    }

    // 写回显存
    particles[id] = p;
}
)";

// [顶点着色器]: 负责把 3D 点画到屏幕上
const char* vertexShaderSource = R"(
#version 430 core
layout (location = 0) in vec4 aPos;  // 虽然我们在SSBO里，但也可以通过VAO读取
layout (location = 1) in vec4 aVel;
layout (location = 2) in vec4 aCol;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 model;

out vec4 vColor;

void main() {
    // aPos.w 存储的是粒子大小
    vec3 pos = aPos.xyz;
    gl_Position = projection * view * model * vec4(pos, 1.0);
    
    // 距离衰减：离得越远，点越小
    float dist = gl_Position.w;
    gl_PointSize = (aPos.w * 800.0) / dist; 
    
    vColor = aCol;
}
)";

// [片元着色器]: 负责上色
const char* fragmentShaderSource = R"(
#version 430 core
out vec4 FragColor;
in vec4 vColor;

void main() {
    // 把方形的点变成圆形的
    vec2 circ = 2.0 * gl_PointCoord - 1.0;
    if (dot(circ, circ) > 1.0) discard;

    // 边缘柔化 (Glow)
    float alpha = 1.0 - dot(circ, circ);
    alpha = pow(alpha, 1.5);

    FragColor = vec4(vColor.rgb, vColor.a * alpha);
}
)";

// --- 6. 辅助函数：编译着色器 ---
unsigned int createShader(const char* source, GLenum type) {
    unsigned int shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, NULL);
    glCompileShader(shader);
    // 错误检查
    int success; char infoLog[512];
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(shader, 512, NULL, infoLog);
        std::cerr << "Shader Error (" << (type == GL_COMPUTE_SHADER ? "COMPUTE" : "GRAPHICS") << "):\n" << infoLog << std::endl;
    }
    return shader;
}

// --- 7. 全局网络变量 ---
SOCKET udpSocket;
sockaddr_in serverAddr;
struct HandData {
    float hasHand; // 0.0 或 1.0
    float scale;
    float rotX;
    float rotY;
} currentHandData = { 0.0f, 1.0f, 0.5f, 0.5f };

// 初始化 UDP
void initUDP() {
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    udpSocket = socket(AF_INET, SOCK_DGRAM, 0);

    // 设置为非阻塞模式 (关键！防止卡顿)
    u_long mode = 1;
    ioctlsocket(udpSocket, FIONBIO, &mode);

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(8888);
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    bind(udpSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));
    std::cout << "UDP Listener started on port 8888" << std::endl;
}

// 读取 UDP 数据
void pollUDP() {
    char buffer[1024];
    sockaddr_in clientAddr;
    int clientLen = sizeof(clientAddr);

    // 循环读取直到缓冲区清空 (取最新数据)
    while (true) {
        int len = recvfrom(udpSocket, buffer, 1024, 0, (sockaddr*)&clientAddr, &clientLen);
        if (len > 0 && len == 16) { // 我们预期收到 4个float = 16字节
            float* data = (float*)buffer;
            currentHandData.hasHand = data[0];
            currentHandData.scale = data[1];
            currentHandData.rotX = data[2];
            currentHandData.rotY = data[3];
        }
        else {
            break; // 没有数据了
        }
    }
}

// --- 8. 主函数 ---
int main() {
    // 8.1 初始化窗口
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // 4x MSAA 抗锯齿 (虽然对粒子影响不大，但对几何体有效)
    glfwWindowHint(GLFW_SAMPLES, 4);

    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Particle Saturn [Native]", NULL, NULL);
    if (!window) { std::cerr << "GLFW Failed" << std::endl; return -1; }
    glfwMakeContextCurrent(window);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "GLAD Failed" << std::endl; return -1;
    }

    // 8.2 编译图形着色器 (顶点+片元)
    unsigned int vShader = createShader(vertexShaderSource, GL_VERTEX_SHADER);
    unsigned int fShader = createShader(fragmentShaderSource, GL_FRAGMENT_SHADER);
    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vShader);
    glAttachShader(shaderProgram, fShader);
    glLinkProgram(shaderProgram);

    // 8.3 编译计算着色器
    unsigned int cShader = createShader(computeShaderSource, GL_COMPUTE_SHADER);
    unsigned int computeProgram = glCreateProgram();
    glAttachShader(computeProgram, cShader);
    glLinkProgram(computeProgram);

    // 8.4 生成土星粒子数据 (CPU端生成一次)
    std::vector<Particle> hostParticles(PARTICLE_COUNT);
    std::default_random_engine generator;
    std::uniform_real_distribution<float> rand01(0.0f, 1.0f);

    std::cout << "Generating " << PARTICLE_COUNT << " particles..." << std::endl;

    for (int i = 0; i < PARTICLE_COUNT; i++) {
        // --- 移植原版 WebGL 的生成逻辑 ---
        float x, y, z, r, g, b, a, size, speed;
        float R_PLANET = 10.0f; // 基础半径缩放

        if (i < PARTICLE_COUNT * 0.25) {
            // [星球本体] (25% 粒子)
            float theta = 6.283f * rand01(generator);
            float phi = acos(2.0f * rand01(generator) - 1.0f);
            float rad = R_PLANET;
            x = rad * sin(phi) * cos(theta);
            y = rad * cos(phi) * 0.9f; // 压扁一点
            z = rad * sin(phi) * sin(theta);

            // 颜色逻辑 (简单的条纹)
            float lat = (y / rad + 1.0f) * 0.5f;
            if (int(lat * 10) % 2 == 0) { r = 0.8f; g = 0.7f; b = 0.5f; } // 亮纹
            else { r = 0.7f; g = 0.6f; b = 0.4f; } // 暗纹
            a = 1.0f; size = 0.1f; speed = 0.0f;
        }
        else {
            // [光环] (75% 粒子)
            float zone = rand01(generator);
            float rad;
            if (zone < 0.15) rad = R_PLANET * (1.2f + rand01(generator) * 0.3f); // C环
            else if (zone < 0.8) rad = R_PLANET * (1.5f + rand01(generator) * 0.5f); // B环
            else rad = R_PLANET * (2.1f + rand01(generator) * 0.3f); // A环

            float theta = rand01(generator) * 6.283f;
            x = rad * cos(theta);
            z = rad * sin(theta);
            y = (rand01(generator) - 0.5f) * 0.2f; // 光环很薄

            // 光环颜色
            r = 0.6f; g = 0.55f; b = 0.5f; a = 0.6f;
            size = 0.05f + rand01(generator) * 0.05f;

            // 开普勒速度模拟: 离得越远跑得越慢
            speed = 5.0f / sqrt(rad);
        }

        hostParticles[i].position = glm::vec4(x, y, z, size);
        hostParticles[i].velocity = glm::vec4(0, 0, 0, speed);
        hostParticles[i].color = glm::vec4(r, g, b, a);
    }

    // 8.5 创建 SSBO 并上传数据到显存
    unsigned int ssbo;
    glGenBuffers(1, &ssbo);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo);
    // 关键：GL_DYNAMIC_DRAW 表示我们需要频繁读写(在GPU内部)
    glBufferData(GL_SHADER_STORAGE_BUFFER, hostParticles.size() * sizeof(Particle), hostParticles.data(), GL_DYNAMIC_DRAW);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, ssbo); // 绑定到 binding point 0

    // 8.6 创建 VAO (为了能够绘制点)
    unsigned int vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, ssbo);

    // 告诉 Vertex Shader 怎么读取 SSBO 里的数据作为顶点属性
    // layout 0: position (vec4) -> stride = sizeof(Particle)
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(Particle), (void*)0);
    // layout 1: velocity (vec4)
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Particle), (void*)(sizeof(glm::vec4)));
    // layout 2: color (vec4)
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, sizeof(Particle), (void*)(2 * sizeof(glm::vec4)));

    glBindVertexArray(0); // 解绑

    // 8.7 初始化网络
    initUDP();

    // 8.8 渲染状态设置
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE); // 叠加混合模式 (让粒子发光)
    glEnable(GL_PROGRAM_POINT_SIZE); // 允许 Shader 控制点大小

    float lastFrame = 0.0f;

    std::cout << "Engine Ready. Rendering..." << std::endl;

    // --- 9. 游戏循环 ---
    while (!glfwWindowShouldClose(window)) {
        // 时间计算
        float currentFrame = (float)glfwGetTime();
        float dt = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // 9.1 读取网络输入
        pollUDP();

        // 9.2 计算着色器阶段 (GPU 物理计算)
        glUseProgram(computeProgram);
        glUniform1f(glGetUniformLocation(computeProgram, "uTime"), currentFrame);
        glUniform1f(glGetUniformLocation(computeProgram, "uDt"), dt);
        glUniform1f(glGetUniformLocation(computeProgram, "uHandScale"), currentHandData.scale);
        glUniform1f(glGetUniformLocation(computeProgram, "uHandHas"), currentHandData.hasHand);

        // 调度计算线程：100万粒子 / 128 (组大小)
        glDispatchCompute((PARTICLE_COUNT + WORK_GROUP_SIZE - 1) / WORK_GROUP_SIZE, 1, 1);

        // 内存屏障：确保计算着色器写完了，顶点着色器再读
        glMemoryBarrier(GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT);

        // 9.3 图形渲染阶段
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        glUseProgram(shaderProgram);

        // 摄像机矩阵
        glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 1000.0f);
        glm::mat4 view = glm::lookAt(glm::vec3(0, 30, 80), glm::vec3(0, 0, 0), glm::vec3(0, 1, 0));

        // 模型矩阵：根据手势位置旋转整个土星
        glm::mat4 model = glm::mat4(1.0f);
        // 手在左边 (-X)，土星向左倾斜；手在上面 (-Y)，土星向前倾斜
        float rotX = (currentHandData.rotY - 0.5f) * 2.0f; // -1 ~ 1
        float rotY = (currentHandData.rotX - 0.5f) * 2.0f; // -1 ~ 1

        model = glm::rotate(model, rotX, glm::vec3(1, 0, 0)); // 俯仰
        model = glm::rotate(model, rotY, glm::vec3(0, 1, 0)); // 自旋

        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(model));

        glBindVertexArray(vao);
        glDrawArrays(GL_POINTS, 0, PARTICLE_COUNT);

        glfwSwapBuffers(window);
        glfwPollEvents();

        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);
    }

    // 清理
    glDeleteBuffers(1, &ssbo);
    glDeleteVertexArrays(1, &vao);
    glDeleteProgram(shaderProgram);
    glDeleteProgram(computeProgram);
    closesocket(udpSocket);
    WSACleanup();
    glfwTerminate();
    return 0;
}